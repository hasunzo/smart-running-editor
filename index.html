<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸƒâ€â™‚ï¸ ìŠ¤ë§ˆíŠ¸ ëŸ¬ë‹ ì¸ì¦ìƒ· ì—ë””í„°</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .panel h2 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.8em;
            text-align: center;
        }

        .upload-section {
            margin-bottom: 30px;
        }

        .upload-box {
            border: 3px dashed #ccc;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-box:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .upload-box.uploaded {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .upload-box input[type="file"] {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .upload-text {
            font-size: 1.1em;
            color: #666;
            margin-top: 10px;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .preview-card {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }

        .preview-card img {
            width: 100%;
            max-height: 200px;
            object-fit: contain;
            border-radius: 8px;
        }

        .controls-section {
            margin: 25px 0;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .control-group select, .control-group button {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .control-group select:focus, .control-group button:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin: 10px 5px;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .canvas-container {
            text-align: center;
            position: relative;
        }

        .canvas-wrapper {
            display: inline-block;
            border: 2px solid #ddd;
            border-radius: 15px;
            overflow: hidden;
            background: #f0f0f0;
            max-width: 100%;
        }

        .status-message {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
        }

        .status-success {
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status-error {
            background: rgba(244, 67, 54, 0.1);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 10px;
            }
            
            .panel {
                padding: 20px;
            }
            
            body {
                padding: 10px;
            }
            
            .upload-box {
                padding: 30px 15px;
                min-height: 120px;
            }
        }

        .crop-mode-info {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ì™¼ìª½ íŒ¨ë„: ì—…ë¡œë“œ ë° ì„¤ì • -->
        <div class="panel">
            <h2>ğŸƒâ€â™‚ï¸ ìŠ¤ë§ˆíŠ¸ ëŸ¬ë‹ ì¸ì¦ìƒ· ì—ë””í„°</h2>
            
            <!-- ë°°ê²½ ì´ë¯¸ì§€ ì—…ë¡œë“œ -->
            <div class="upload-section">
                <h3>ğŸ“¸ ë°°ê²½ ëŸ¬ë‹ ì‚¬ì§„</h3>
                <div class="upload-box" id="backgroundUpload">
                    <div class="upload-icon">ğŸŒ„</div>
                    <div class="upload-text">ë°°ê²½ ëŸ¬ë‹ ì‚¬ì§„ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•´ì£¼ì„¸ìš”</div>
                    <input type="file" id="backgroundFile" accept="image/*">
                </div>
                <div class="preview-card" id="backgroundPreview">
                    <img id="backgroundImg" alt="ë°°ê²½ ë¯¸ë¦¬ë³´ê¸°">
                </div>
            </div>

            <!-- ëŸ¬ë‹ ê¸°ë¡ ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ -->
            <div class="upload-section">
                <h3>ğŸ“± ëŸ¬ë‹ ê¸°ë¡ ìŠ¤í¬ë¦°ìƒ·</h3>
                <div class="upload-box" id="statsUpload">
                    <div class="upload-icon">ğŸ“Š</div>
                    <div class="upload-text">ëŸ¬ë‹ ê¸°ë¡ ìŠ¤í¬ë¦°ìƒ·ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•´ì£¼ì„¸ìš”</div>
                    <input type="file" id="statsFile" accept="image/*">
                </div>
                <div class="preview-card" id="statsPreview">
                    <img id="statsImg" alt="ê¸°ë¡ ë¯¸ë¦¬ë³´ê¸°">
                </div>
            </div>

            <!-- ì„¤ì • ì„¹ì…˜ -->
            <div class="controls-section">
                <div class="control-group">
                    <label for="cropMode">ğŸ¯ í¬ë¡­í•‘ ëª¨ë“œ</label>
                    <select id="cropMode">
                        <option value="auto">ìë™ ê°ì§€ (AI ì¶”ì²œ)</option>
                        <option value="manual">ìˆ˜ë™ í¬ë¡­</option>
                        <option value="full">ì „ì²´ ì‚¬ìš©</option>
                    </select>
                    <div class="crop-mode-info" id="cropModeInfo">
                        AIê°€ ëŸ¬ë‹ ê¸°ë¡ ì˜ì—­ì„ ìë™ìœ¼ë¡œ ê°ì§€í•©ë‹ˆë‹¤
                    </div>
                </div>

                <div class="control-group">
                    <label for="textColor">âœ¨ ê¸€ì ìƒ‰ìƒ ëª¨ë“œ</label>
                    <select id="textColor">
                        <option value="original">ì›ë³¸ ìƒ‰ìƒ ìœ ì§€</option>
                        <option value="white">í•˜ì–€ìƒ‰ ê¸€ì</option>
                        <option value="shadow">ì•„ì›ƒë¼ì¸ íš¨ê³¼</option>
                    </select>
                </div>

                <button class="btn-primary" id="processBtn" disabled>
                    ğŸ¨ í•©ì„±í•˜ê¸°
                </button>
                
                <button class="btn-primary" id="downloadBtn" disabled>
                    ğŸ’¾ ë‹¤ìš´ë¡œë“œ
                </button>
            </div>

            <div id="statusMessage"></div>
        </div>

        <!-- ì˜¤ë¥¸ìª½ íŒ¨ë„: ìº”ë²„ìŠ¤ -->
        <div class="panel">
            <h2>ğŸ¨ ê²°ê³¼ë¬¼ ë¯¸ë¦¬ë³´ê¸°</h2>
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="fabricCanvas" width="600" height="400"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let fabric_canvas;
        let backgroundImageData = null;
        let statsImageData = null;
        let processedStatsImage = null;

        // Fabric.js ì´ˆê¸°í™” ëŒ€ê¸°
        function waitForFabric() {
            return new Promise((resolve) => {
                if (typeof fabric !== 'undefined') {
                    resolve();
                } else {
                    setTimeout(() => waitForFabric().then(resolve), 100);
                }
            });
        }

        // ì´ˆê¸°í™”
        async function initialize() {
            await waitForFabric();
            
            fabric_canvas = new fabric.Canvas('fabricCanvas', {
                width: 600,
                height: 400,
                backgroundColor: '#f0f0f0'
            });

            setupEventListeners();
            updateCropModeInfo();
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupEventListeners() {
            // íŒŒì¼ ì—…ë¡œë“œ
            document.getElementById('backgroundFile').addEventListener('change', handleBackgroundUpload);
            document.getElementById('statsFile').addEventListener('change', handleStatsUpload);
            
            // ë“œë˜ê·¸ ì•¤ ë“œë¡­
            setupDragAndDrop('backgroundUpload', 'backgroundFile');
            setupDragAndDrop('statsUpload', 'statsFile');
            
            // ì»¨íŠ¸ë¡¤
            document.getElementById('cropMode').addEventListener('change', updateCropModeInfo);
            document.getElementById('processBtn').addEventListener('click', processImages);
            document.getElementById('downloadBtn').addEventListener('click', downloadResult);
        }

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„¤ì •
        function setupDragAndDrop(uploadBoxId, fileInputId) {
            const uploadBox = document.getElementById(uploadBoxId);
            const fileInput = document.getElementById(fileInputId);

            uploadBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadBox.style.borderColor = '#667eea';
            });

            uploadBox.addEventListener('dragleave', () => {
                uploadBox.style.borderColor = '#ccc';
            });

            uploadBox.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadBox.style.borderColor = '#ccc';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    fileInput.dispatchEvent(new Event('change'));
                }
            });
        }

        // ë°°ê²½ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì²˜ë¦¬
        function handleBackgroundUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                backgroundImageData = event.target.result;
                
                const img = document.getElementById('backgroundImg');
                img.src = backgroundImageData;
                document.getElementById('backgroundPreview').style.display = 'block';
                document.getElementById('backgroundUpload').classList.add('uploaded');
                
                checkReadyToProcess();
                showStatus('ë°°ê²½ ì´ë¯¸ì§€ê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤! âœ…', 'success');
            };
            reader.readAsDataURL(file);
        }

        // ëŸ¬ë‹ ê¸°ë¡ ì—…ë¡œë“œ ì²˜ë¦¬
        function handleStatsUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                statsImageData = event.target.result;
                
                const img = document.getElementById('statsImg');
                img.src = statsImageData;
                document.getElementById('statsPreview').style.display = 'block';
                document.getElementById('statsUpload').classList.add('uploaded');
                
                checkReadyToProcess();
                showStatus('ëŸ¬ë‹ ê¸°ë¡ ìŠ¤í¬ë¦°ìƒ·ì´ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤! âœ…', 'success');
            };
            reader.readAsDataURL(file);
        }

        // ì²˜ë¦¬ ì¤€ë¹„ ìƒíƒœ í™•ì¸
        function checkReadyToProcess() {
            const processBtn = document.getElementById('processBtn');
            if (backgroundImageData && statsImageData) {
                processBtn.disabled = false;
                showStatus('ëª¨ë“  ì´ë¯¸ì§€ê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤! í•©ì„± ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš” ğŸ¨', 'success');
            }
        }

        // í¬ë¡­ ëª¨ë“œ ì •ë³´ ì—…ë°ì´íŠ¸
        function updateCropModeInfo() {
            const mode = document.getElementById('cropMode').value;
            const info = document.getElementById('cropModeInfo');
            
            const infoTexts = {
                'auto': 'AIê°€ ëŸ¬ë‹ ê¸°ë¡ ì˜ì—­ì„ ìë™ìœ¼ë¡œ ê°ì§€í•©ë‹ˆë‹¤',
                'manual': 'ë§ˆìš°ìŠ¤ë¡œ ì§ì ‘ ì˜ì—­ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                'full': 'ìŠ¤í¬ë¦°ìƒ· ì „ì²´ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤'
            };
            
            info.textContent = infoTexts[mode];
        }

        // ìŠ¤ë§ˆíŠ¸ í¬ë¡­í•‘ ì•Œê³ ë¦¬ì¦˜
        function smartCropRunningStats(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            let minX = width, maxX = 0, minY = height, maxY = 0;
            let textPixels = [];
            
            // í…ìŠ¤íŠ¸/ìˆ«ì í”½ì…€ ê°ì§€ (brightness < 120)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const brightness = (r + g + b) / 3;
                    
                    if (brightness < 120) {
                        textPixels.push({x, y});
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // ìƒë‹¨ 40% ì˜ì—­ì˜ í° ìˆ«ìë“¤ ìš°ì„  í¬í•¨
            const topRegion = height * 0.4;
            const importantPixels = textPixels.filter(p => p.y < topRegion);
            
            if (importantPixels.length > 0) {
                const impMinY = Math.min(...importantPixels.map(p => p.y));
                minY = Math.min(minY, impMinY);
            }
            
            // ì ì ˆí•œ ì—¬ë°± ì¶”ê°€ (10% ë§ˆì§„)
            const margin = Math.min(width, height) * 0.1;
            minX = Math.max(0, minX - margin);
            maxX = Math.min(width, maxX + margin);
            minY = Math.max(0, minY - margin);
            maxY = Math.min(height, maxY + margin);
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        // ê³ ê¸‰ ë°°ê²½ ì œê±° ì•Œê³ ë¦¬ì¦˜
        function advancedRemoveBackground(ctx, width, height, colorMode) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // ê°€ì¥ìë¦¬ í”½ì…€ë¡œ ë°°ê²½ìƒ‰ ìë™ ê°ì§€
            let bgR = 0, bgG = 0, bgB = 0;
            let edgePixelCount = 0;
            
            // ê°€ì¥ìë¦¬ 20í”½ì…€ ìƒ˜í”Œë§
            const edgeSize = 20;
            for (let i = 0; i < edgeSize && i < width; i++) {
                for (let j = 0; j < edgeSize && j < height; j++) {
                    const positions = [
                        j * width + i,  // ì™¼ìª½ ìœ„
                        j * width + (width - 1 - i),  // ì˜¤ë¥¸ìª½ ìœ„
                        (height - 1 - j) * width + i,  // ì™¼ìª½ ì•„ë˜
                        (height - 1 - j) * width + (width - 1 - i)  // ì˜¤ë¥¸ìª½ ì•„ë˜
                    ];
                    
                    positions.forEach(pos => {
                        if (pos * 4 < data.length) {
                            bgR += data[pos * 4];
                            bgG += data[pos * 4 + 1];
                            bgB += data[pos * 4 + 2];
                            edgePixelCount++;
                        }
                    });
                }
            }
            
            bgR /= edgePixelCount;
            bgG /= edgePixelCount;
            bgB /= edgePixelCount;
            
            // ì„ê³„ê°’ ê¸°ë°˜ ë°°ê²½/í…ìŠ¤íŠ¸ êµ¬ë¶„
            const threshold = 40;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // ìœ í´ë¦¬ë“œ ê±°ë¦¬ë¡œ ë°°ê²½ íŒë‹¨
                const distance = Math.sqrt(
                    Math.pow(r - bgR, 2) + 
                    Math.pow(g - bgG, 2) + 
                    Math.pow(b - bgB, 2)
                );
                
                if (distance < threshold) {
                    // ë°°ê²½ìœ¼ë¡œ íŒë‹¨ - íˆ¬ëª…í™”
                    data[i + 3] = 0;
                } else {
                    // í…ìŠ¤íŠ¸ë¡œ íŒë‹¨ - ìƒ‰ìƒ ëª¨ë“œ ì ìš©
                    switch (colorMode) {
                        case 'white':
                            data[i] = 255;      // R
                            data[i + 1] = 255;  // G
                            data[i + 2] = 255;  // B
                            data[i + 3] = 255;  // A
                            break;
                        case 'shadow':
                            // í° ê¸€ìë¡œ ë³€í™˜
                            data[i] = 255;
                            data[i + 1] = 255;
                            data[i + 2] = 255;
                            data[i + 3] = 255;
                            break;
                        case 'original':
                        default:
                            // ì›ë³¸ ìƒ‰ìƒ ìœ ì§€í•˜ë©´ì„œ ëŒ€ë¹„ ê°•í™”
                            if (r + g + b < 300) {  // ì–´ë‘ìš´ ìƒ‰ìƒì¸ ê²½ìš°
                                data[i] = Math.max(0, r - 20);
                                data[i + 1] = Math.max(0, g - 20);
                                data[i + 2] = Math.max(0, b - 20);
                            }
                            data[i + 3] = 255;
                            break;
                    }
                }
            }
            
            // ì•„ì›ƒë¼ì¸ íš¨ê³¼ë¥¼ ìœ„í•œ ì¶”ê°€ ì²˜ë¦¬
            if (colorMode === 'shadow') {
                const shadowData = new Uint8ClampedArray(data);
                
                // 3x3 ì»¤ë„ì„ ì‚¬ìš©í•œ morphological ì—°ì‚°
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        if (data[idx + 3] > 0) {  // í…ìŠ¤íŠ¸ í”½ì…€ì¸ ê²½ìš°
                            // ì£¼ë³€ 8í”½ì…€ ê²€ì‚¬
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const neighborIdx = ((y + dy) * width + (x + dx)) * 4;
                                    if (data[neighborIdx + 3] === 0) {  // íˆ¬ëª… í”½ì…€ ê·¼ì²˜
                                        // ê²€ì€ ì•„ì›ƒë¼ì¸ ì¶”ê°€
                                        shadowData[neighborIdx] = 0;      // R
                                        shadowData[neighborIdx + 1] = 0;  // G
                                        shadowData[neighborIdx + 2] = 0;  // B
                                        shadowData[neighborIdx + 3] = 180; // ë°˜íˆ¬ëª…
                                    }
                                }
                            }
                        }
                    }
                }
                
                // ì•„ì›ƒë¼ì¸ ì ìš©
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] === 0 && shadowData[i + 3] > 0) {
                        data[i] = shadowData[i];
                        data[i + 1] = shadowData[i + 1];
                        data[i + 2] = shadowData[i + 2];
                        data[i + 3] = shadowData[i + 3];
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        // ì´ë¯¸ì§€ ì²˜ë¦¬ ë©”ì¸ í•¨ìˆ˜
        async function processImages() {
            if (!backgroundImageData || !statsImageData) return;
            
            showStatus('<div class="loading"></div>ì´ë¯¸ì§€ë¥¼ ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤...', 'success');
            document.getElementById('processBtn').disabled = true;
            
            try {
                // ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ
                const bgImg = await loadImage(backgroundImageData);
                
                // ëŸ¬ë‹ ê¸°ë¡ ì´ë¯¸ì§€ ì²˜ë¦¬
                const statsImg = await loadImage(statsImageData);
                const processedStats = await processStatsImage(statsImg);
                
                // Fabric.js ìº”ë²„ìŠ¤ì— í•©ì„±
                await compositeImages(bgImg, processedStats);
                
                showStatus('ì´ë¯¸ì§€ í•©ì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰', 'success');
                document.getElementById('downloadBtn').disabled = false;
                
            } catch (error) {
                console.error('ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
                showStatus('ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'error');
            } finally {
                document.getElementById('processBtn').disabled = false;
            }
        }

        // ì´ë¯¸ì§€ ë¡œë“œ í—¬í¼
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        // ëŸ¬ë‹ ê¸°ë¡ ì´ë¯¸ì§€ ì²˜ë¦¬
        async function processStatsImage(statsImg) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = statsImg.width;
            canvas.height = statsImg.height;
            ctx.drawImage(statsImg, 0, 0);
            
            const cropMode = document.getElementById('cropMode').value;
            const colorMode = document.getElementById('textColor').value;
            
            let cropArea = {
                x: 0,
                y: 0,
                width: canvas.width,
                height: canvas.height
            };
            
            // í¬ë¡­í•‘ ëª¨ë“œì— ë”°ë¥¸ ì²˜ë¦¬
            if (cropMode === 'auto') {
                cropArea = smartCropRunningStats(ctx, canvas.width, canvas.height);
            }
            
            // í¬ë¡­ëœ ì˜ì—­ë§Œ ì¶”ì¶œ
            const croppedCanvas = document.createElement('canvas');
            const croppedCtx = croppedCanvas.getContext('2d');
            
            croppedCanvas.width = cropArea.width;
            croppedCanvas.height = cropArea.height;
            
            croppedCtx.drawImage(
                canvas,
                cropArea.x, cropArea.y, cropArea.width, cropArea.height,
                0, 0, cropArea.width, cropArea.height
            );
            
            // ë°°ê²½ ì œê±° ë° ìƒ‰ìƒ ë³€ê²½
            advancedRemoveBackground(croppedCtx, croppedCanvas.width, croppedCanvas.height, colorMode);
            
            // Fabric.js Image ê°ì²´ë¡œ ë³€í™˜
            return new Promise((resolve) => {
                fabric.Image.fromURL(croppedCanvas.toDataURL(), (img) => {
                    resolve(img);
                });
            });
        }

        // ì´ë¯¸ì§€ í•©ì„±
        async function compositeImages(bgImg, statsImg) {
            // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ë°°ê²½ ì´ë¯¸ì§€ì— ë§ê²Œ ì¡°ì •
            const aspectRatio = bgImg.width / bgImg.height;
            let canvasWidth = 600;
            let canvasHeight = 600 / aspectRatio;
            
            if (canvasHeight > 400) {
                canvasHeight = 400;
                canvasWidth = 400 * aspectRatio;
            }
            
            fabric_canvas.setDimensions({
                width: canvasWidth,
                height: canvasHeight
            });
            
            // ê¸°ì¡´ ê°ì²´ ì œê±°
            fabric_canvas.clear();
            
            // ë°°ê²½ ì´ë¯¸ì§€ ì¶”ê°€
            const fabricBgImg = await new Promise((resolve) => {
                fabric.Image.fromURL(backgroundImageData, (img) => {
                    img.set({
                        left: 0,
                        top: 0,
                        scaleX: canvasWidth / bgImg.width,
                        scaleY: canvasHeight / bgImg.height,
                        selectable: false
                    });
                    resolve(img);
                });
            });
            
            fabric_canvas.add(fabricBgImg);
            
            // ëŸ¬ë‹ ê¸°ë¡ ì´ë¯¸ì§€ ì¶”ê°€
            const maxStatsWidth = canvasWidth * 0.4;
            const scale = Math.min(maxStatsWidth / statsImg.width, 1);
            
            statsImg.set({
                left: canvasWidth * 0.05,
                top: canvasHeight * 0.05,
                scaleX: scale,
                scaleY: scale,
                shadow: new fabric.Shadow({
                    color: 'rgba(0,0,0,0.3)',
                    blur: 10,
                    offsetX: 3,
                    offsetY: 3
                })
            });
            
            fabric_canvas.add(statsImg);
            fabric_canvas.setActiveObject(statsImg);
            fabric_canvas.renderAll();
            
            processedStatsImage = statsImg;
        }

        // ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥
        function downloadResult() {
            if (!fabric_canvas) return;
            
            // ì„ íƒ ìƒíƒœ í•´ì œ
            fabric_canvas.discardActiveObject();
            fabric_canvas.renderAll();
            
            // ê³ í’ˆì§ˆ ë‹¤ìš´ë¡œë“œë¥¼ ìœ„í•œ ì„ì‹œ ìº”ë²„ìŠ¤
            const downloadCanvas = document.createElement('canvas');
            const downloadCtx = downloadCanvas.getContext('2d');
            
            // ì›ë³¸ í•´ìƒë„ë¡œ í™•ëŒ€
            const scale = 2;
            downloadCanvas.width = fabric_canvas.width * scale;
            downloadCanvas.height = fabric_canvas.height * scale;
            
            downloadCtx.scale(scale, scale);
            downloadCtx.drawImage(fabric_canvas.lowerCanvasEl, 0, 0);
            
            // ë‹¤ìš´ë¡œë“œ
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
            link.download = `ìŠ¤ë§ˆíŠ¸_ëŸ¬ë‹_ì¸ì¦ìƒ·_${timestamp}.png`;
            link.href = downloadCanvas.toDataURL('image/png', 1.0);
            link.click();
            
            showStatus('ì´ë¯¸ì§€ê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ“', 'success');
        }

        // ìƒíƒœ ë©”ì‹œì§€ í‘œì‹œ
        function showStatus(message, type = 'success') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 3000);
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>